@page "/CartPage"
@attribute [Authorize]

@using Microsoft.AspNetCore.Authorization;
@using Newtonsoft.Json;
@using TicketHive_MadCats.Client.Cookies
@using TicketHive_MadCats.Shared.ViewModels;
@inject NavigationManager navMan
@inject IJSRuntime JsRuntime

<h3>CartPage</h3>

@if(cart != null && cart.Count > 0)
{
	<div class="row text-center justify-content-center border-2 border-dark">

		@foreach (var kvp in cart)
		{
			<div>
				<span>Event @selectedEvent.Name | No. tickets in cart: @bookedTickets | Total price: @(selectedEvent.TicketPrice * bookedTickets)</span>
				<br>
				<div>
					<button @onclick="@(async () => await RemoveFromCart(kvp.Key))">Remove</button>
					<button @onclick="@(async () => await AddToCart(kvp.Key))">Add</button>
				</div>
			</div>
		}

	</div>

	// ENDA RADEN SOM BEHÖVS FÖR ATT ÄNDRA VARUKORG
	@*cart = await cookieInt.UpdateCookieForSingleEvent(eventName, quantity)*@
}
else if (cart != null && cart.Count == 0)
{
	<span>Your cart is empty</span>
}
else if (cart == null)
{
	<span>Loading cart...</span>
}



@code {
	[Parameter]
	public int Id { get; set; }
	[Inject]
	public IJSRuntime jS { get; set; }
	[Inject]
	HttpClient codeClient { get; set; }

	public CookieInterpreter? cookieInt;
	public Dictionary<string, int>? cart = null;

	public EventViewModel? Event;

	// Nytt som jag lade till för att lyckas få över hela objektet från EventPage
	private EventViewModel selectedEvent;
	private int bookedTickets;



	protected override async Task OnParametersSetAsync()
	{
		cookieInt = new(jS);
		Event = await GetOneEvent();
		await StartReadingCookie();
	}

	// Tar emot hela objektet ifrån EventPage, vi kan nog lägga in cookieInt = new(Js) och await StartReadingCookie(); här för dynamiska grejer, tror jag.
	protected override void OnInitialized()
	{
		var query = navMan.ToAbsoluteUri(navMan.Uri).Query;
		var parameters = System.Web.HttpUtility.ParseQueryString(query);
		var serializedEvent = parameters["event"];
		var tickets = parameters["tickets"];

		if (!string.IsNullOrEmpty(serializedEvent) && int.TryParse(tickets, out int result))
		{
			bookedTickets = result;
			selectedEvent = JsonConvert.DeserializeObject<EventViewModel>(serializedEvent);
		}
	}

	public async Task StartReadingCookie()
	{
		Dictionary<string, int>? response = await cookieInt.ReadCookie();

		if(response != null)
		{
			cart = response;
		}
		else
		{

			cart = new();
		}
	}

	public async Task RemoveFromCart(string eventName)
	{
		int newQuantity = cart[eventName] - 1;
		cart = await cookieInt.UpdateCookieForSingleEvent(eventName, -1);
	}

	public async Task AddToCart(string eventName)
	{
		int newQuantity = cart[eventName] + 1;
		cart = await cookieInt.UpdateCookieForSingleEvent(eventName, 1);
	}

	public async Task<EventViewModel?> GetOneEvent()
	{
		var response = await codeClient.GetAsync($"api/Events/{Id}");
		var statusCode = response.StatusCode;
		if (statusCode == System.Net.HttpStatusCode.OK)
		{
			var responseBody = await response.Content.ReadAsStringAsync();
			EventViewModel? eventVM = JsonConvert.DeserializeObject<EventViewModel?>(responseBody);

			return eventVM;
		}
		return null;
	}


	// Metod som ej används atm.
	//public int totalPrice(string eventName, int quantity)
	//{
	//	if (Event == null) return 0;

	//	int eventPrice = Event.TicketPrice * quantity;
	//	int totalPrice = cart.Sum(kvp => kvp.Key == eventName ? eventPrice : kvp.Value * Event.TicketPrice);
	//	return totalPrice;
	//}





}
